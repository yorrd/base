<link rel="import" href="../bower_components/polymer-redux/polymer-redux.html">

<script>
import { createStore, applyMiddleware } from 'redux';
import DatabaseHolder from './database-holder';

// TODO remove this, it's a stupid idea because we already have the redux
// time machine. Just for testing the combiner
const debugReducer = (state = ['No debug message'], action) => {
    let logMessage = '';
    switch (action.type) {
            case 'INSERT_DOC':
                logMessage = `Insert new Item: ${JSON.stringify(action.doc)}`;
                break;
            case 'REMOVE_DOC':
                logMessage = `Remove Item: ${JSON.stringify(action.doc)}`;
                break;
            case 'ADDED_DOC':
                logMessage = `Inserted new Item: ${JSON.stringify(action.doc)}`;
                break;
            case 'REMOVED_DOC':
                logMessage = `Deleted Item: ${JSON.stringify(action.doc)}`;
                break;
            case 'UPDATED_DOC':
                logMessage = `Updated Item: ${JSON.stringify(action.doc)}`;
                break;
            case 'SET_FILTER':
                logMessage = `Set Filter: ${JSON.stringify(action.filter)}`;
                break;
            default:
            // ignore
    }
    return [...state, logMessage];
};

const reducer = (state = {}, action) => {
    let object = Object.assign({}, state);
    switch (action.type) {
            // actions which are only called from the observer on the mongo database
            case 'ADDED_DOC': {
                if (!state[action.statePath]) {
                    object[action.statePath] = [action.doc];
                } else {
                    object[action.statePath] = [...state[action.statePath], action.doc];
                }
                break;
            }
            case 'REMOVED_DOC': {
                if (!state[action.statePath]) {
                    object[action.statePath] = [];
                } else {
                    object[action.statePath] = state[action.statePath].filter(item => item._id !== action.doc._id);
                }
                break;
            }
            case 'UPDATED_DOC': {
                if (!state[action.statePath]) {
                    object[action.statePath] = [];
                } else {
                    object[action.statePath] = state[action.statePath].map((item) => {
                        if (item._id === action.doc._id) { return action.doc; }
                        return item;
                    });
                }
                break;
            }

            // filter action for the respective statePath / collection. We're claling this "statePath"_filter
            case 'SET_FILTER': {
                object[action.statePath] = [];
                // TODO better do .filter here? instead of _filter
                object[`${action.statePath}_filter`] = action.filter;
                break;
            }
            default:
                object = Object.assign({}, state);
    }

    // insert polymer tracked variables
    if (action.type === 'UPDATE_POLYMER_VARIABLE') {
        object[action.statePath] = action.value;
    }

    // TODO could / should use combineReducers here
    return Object.assign(object, {
        debugMessage: debugReducer(state.debugMessage, action),
    });
};


const mongoMiddleware = middlewareStore => next => (action) => {
    switch (action.type) {
            case 'INSERT_DOC':
                DatabaseHolder.getDatabase(action.collection).insert(action.doc);
                break;
            case 'REMOVE_DOC':
                DatabaseHolder.getDatabase(action.collection).remove({ _id: action.id });
                break;
            default:
    }

    const returnValue = next(action);

    if (action.type === 'SET_FILTER') {
        // TODO move to the constructor or something?
        DatabaseHolder.stopObserverHandle(action.statePath);
        const obsHandle = DatabaseHolder.getDatabase(action.collection).find(action.filter).observe({
            added: (doc) => {
                middlewareStore.dispatch({
                    type: 'ADDED_DOC',
                    collection: action.collection,
                    statePath: action.statePath,
                    doc,
                });
            },
            changed: (doc) => {
                middlewareStore.dispatch({
                    type: 'UPDATED_DOC',
                    collection: action.collection,
                    statePath: action.statePath,
                    doc,
                });
            },
            removed: (doc) => {
                middlewareStore.dispatch({
                    type: 'REMOVED_DOC',
                    collection: action.collection,
                    statePath: action.statePath,
                    doc,
                });
            },
        });
        DatabaseHolder.setObserverHandle(action.statePath, obsHandle);
    }

    return returnValue;
};
const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose; // for the debugger in the browser
const store = createStore(reducer, {/* SSR hydration!!! */}, composeEnhancers(applyMiddleware(mongoMiddleware)));
ReduxMixin = PolymerRedux(store);

AdornisPolymerRedux = (Parent, CollectionName, StatePath) => class AdornisPolymerRedux extends ReduxMixin(Parent) {
    static get actions() {
        return {
            insert(doc) {
                return {
                    type: 'INSERT_DOC',
                    collection: CollectionName,
                    statePath: StatePath,
                    doc,
                };
            },
            remove(id) {
                return {
                    type: 'REMOVE_DOC',
                    collection: CollectionName,
                    statePath: StatePath,
                    id,
                };
            },
            filter(filter) {
                return {
                    type: 'SET_FILTER',
                    collection: CollectionName,
                    statePath: StatePath,
                    filter,
                };
            },
        };
    }

    constructor() {
        super();

        // TODO make collection optional
        if (CollectionName && StatePath) {
            // create observers for the database redux statePath
            Object.keys(this.constructor.properties)
                .filter(prop => this.constructor.properties[prop].statePath === StatePath)
                .forEach((prop) => {
                    this._createMethodObserver(`_arrayUpdate(${prop}.*)`);
                });

            // listen for filter change
            this._createPropertyObserver('filter', '_changeFilter');

            // show warning if you don't have a filter
            if (!Object.keys(this.constructor.properties).includes('filter')) {
                console.error(`You don't have a filter for ${StatePath} on collection ${CollectionName}`);
            }
        }

        // get automatically managed properties
        const props = this.constructor.properties;
        const trackedProperties = Object.keys(props)
            .filter(prop => props[prop].dispatch)
            .forEach((trackedProp) => {
                const { statePath } = props[trackedProp];
                if (statePath.includes('.')) throw new Error("no nested polymer properties allowed at this time for the 'dispatch' shorthand");
                const listenerName = `_trackedPropChanged__${statePath.replace('.', '_')}`;
                if (!statePath) throw new Error(`dispatch given but not statePath for property ${trackedProp}`);

                this[listenerName] = (newVal) => {
                    if (!newVal) return;
                    this.dispatch({
                        type: 'UPDATE_POLYMER_VARIABLE',
                        statePath,
                        value: newVal,
                    });
                };

                this._createPropertyObserver(trackedProp, listenerName);
            });
    }

    _arrayUpdate(diff) { // eslint-disable-line class-methods-use-this
        // this should only run if there are deeper level updates in an object within the array from the database
        if (diff.path.indexOf('.') === -1) return;
        const id = (diff.path.split('.')[1]);
        const dbObj = diff.base[id];
        // will automatically trigger the mongo observer which will then update the data in the store
        DatabaseHolder.getDatabase(CollectionName).update({ _id: dbObj._id }, { $set: dbObj });
    }

    _changeFilter() {
        this.dispatch('filter', this.filter);
    }

    // convenience methods

    _div(a, b) {
        return +a / +b;
    }

    _mul(...args) {
        return args.reduce((prod, curr) => prod * curr, 1);
    }

    _sum(...args) {
        return args.reduce((prod, curr) => prod + curr, 0);
    }

    _sub(a, b) {
        return +a - +b;
    }
};
</script>
