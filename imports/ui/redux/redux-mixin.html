<link rel="import" href="../bower_components/polymer-redux/polymer-redux.html">

<script>
import { createStore, applyMiddleware } from 'redux';
import DatabaseHolder from './database-holder';

const reducer = (state = {}, action) => {
    let object = Object.assign({}, state);
    switch (action.type) {
            // actions which are only called from the observer on the mongo database
            case 'ADDED_DOC': {
                // replace the non-hydrated
                if (!state[action.statePath]) {
                    object[action.statePath] = [action.doc];
                } else {
                    const hydrateIndex = state[action.statePath].findIndex(obj => !obj._id);
                    if (hydrateIndex > -1) {
                        state[action.statePath].splice(hydrateIndex, 1, action.doc);
                        object[action.statePath] = [...state[action.statePath]];
                    } else object[action.statePath] = [...state[action.statePath], action.doc];
                }
                break;
            }
            case 'REMOVED_DOC': {
                if (!state[action.statePath]) {
                    object[action.statePath] = [];
                } else {
                    object[action.statePath] = state[action.statePath].filter(item => item._id !== action.doc._id);
                }
                break;
            }
            case 'UPDATED_DOC': {
                if (!state[action.statePath]) {
                    object[action.statePath] = [];
                } else {
                    object[action.statePath] = state[action.statePath].map((item) => {
                        if (item._id === action.doc._id) { return action.doc; }
                        return item;
                    });
                }
                break;
            }
            default:
                object = Object.assign({}, state);
    }

    // insert polymer tracked variables
    if (action.type === 'UPDATE_POLYMER_VARIABLE') {
        object[action.statePath] = action.value;
    }

    // TODO could / should use combineReducers here
    return Object.assign(object, {
    });
};


const mongoMiddleware = middlewareStore => next => (action) => {
    switch (action.type) {
            case 'INSERT_DOC':
                DatabaseHolder.getDatabase(action.collection).insert(action.doc);
                break;
            case 'REMOVE_DOC':
                DatabaseHolder.getDatabase(action.collection).remove({ _id: action.id });
                break;
            case 'SUBSCRIBE': {
                DatabaseHolder.stopObserverHandle(action.statePath);
                const obsHandle = DatabaseHolder.getDatabase(action.collection).find({}).observe({
                    added: (doc) => {
                        middlewareStore.dispatch({
                            type: 'ADDED_DOC',
                            collection: action.collection,
                            statePath: action.statePath,
                            doc,
                        });
                    },
                    changed: (doc) => {
                        middlewareStore.dispatch({
                            type: 'UPDATED_DOC',
                            collection: action.collection,
                            statePath: action.statePath,
                            doc,
                        });
                    },
                    removed: (doc) => {
                        middlewareStore.dispatch({
                            type: 'REMOVED_DOC',
                            collection: action.collection,
                            statePath: action.statePath,
                            doc,
                        });
                    },
                });
                DatabaseHolder.setObserverHandle(action.statePath, obsHandle, action.collection, action.parameters);
                break;
            }
            default:
    }

    const returnValue = next(action);

    return returnValue;
};
const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || (x => x); // for the debugger in the browser
const store = createStore(reducer, {/* SSR hydration!!! */}, composeEnhancers(applyMiddleware(mongoMiddleware)));
ReduxMixin = PolymerRedux(store);

AdornisPolymerRedux = Parent => class AdornisPolymerRedux extends ReduxMixin(Parent) {
    static get actions() {
        return {
            insert(doc, collection, statePath) {
                if (!doc || !collection || !statePath) throw new Error('no doc, collection or statePath given');
                return {
                    type: 'INSERT_DOC',
                    collection,
                    statePath,
                    doc,
                };
            },
            remove(id, collection, statePath) {
                if (!id || !collection || !statePath) throw new Error('no id, collection or statePath given');
                return {
                    type: 'REMOVE_DOC',
                    collection,
                    statePath,
                    id,
                };
            },
            subscribe(params, collection, statePath) {
                if (!params || !collection || !statePath) throw new Error('no params, collection or statePath given');
                return {
                    type: 'SUBSCRIBE',
                    parameters: params,
                    collection,
                    statePath,
                };
            },
        };
    }

    constructor() {
        super();

        const props = this.constructor.properties;

        // subscribe to all databases required by the properties
        Object.keys(props)
            .filter(prop => props[prop].collection)
            .forEach((dbProp) => {
                const propObj = props[dbProp];
                let parameters = this[propObj.paramProperty];
                if (!parameters) parameters = [];
                this.dispatch('subscribe', parameters, propObj.collection, propObj.statePath);
                this._createMethodObserver(`_arrayUpdate(${dbProp}.*)`);

                // listen for filter changes
                const filterListenerName = `_changeFilter_${propObj.statePath}`;
                this[filterListenerName] = (params) => {
                    this.dispatch('subscribe', params, propObj.collection, propObj.statePath);
                };
                this._createPropertyObserver(propObj.paramProperty, filterListenerName);
            });

        // get automatically managed polymer properties
        Object.keys(props)
            .filter(prop => props[prop].dispatch)
            .forEach((trackedProp) => {
                const { statePath } = props[trackedProp];
                if (statePath.includes('.')) throw new Error("no nested polymer properties allowed at this time for the 'dispatch' shorthand");
                const listenerName = `_trackedPropChanged__${statePath.replace('.', '_')}`;
                if (!statePath) throw new Error(`dispatch given but not statePath for property ${trackedProp}`);

                this[listenerName] = (newVal) => {
                    if (!newVal) return;
                    this.dispatch({
                        type: 'UPDATE_POLYMER_VARIABLE',
                        statePath,
                        value: newVal,
                    });
                };

                this._createPropertyObserver(trackedProp, listenerName);
            });

        // if there is no dispatch but a statepath, don't allow a value, would be overridden instantly anyways
        Object.keys(props)
            .filter(prop => !props[prop].dispatch && props[prop].statePath)
            .forEach((trackedProp) => {
                if (props[trackedProp].value) throw new Error(`there should be no value on the dispatch field ${trackedProp}`);
            });
    }

    _arrayUpdate(diff) { // eslint-disable-line class-methods-use-this
        const propName = diff.path.split('.')[0];
        const collName = this.constructor.properties[propName].collection;

        // this is for removals and additions
        if (diff.path.indexOf('.splices') > -1) {
            diff.value.indexSplices.forEach((id) => {
                id.removed.forEach((obj) => {
                    DatabaseHolder.getDatabase(collName).remove({ _id: obj._id });
                });
                if (id.addedCount === 1) {
                    DatabaseHolder.getDatabase(collName).insert(id.object[id.index]);
                }
                if (id.addedCount > 1) throw new Error('multiple additions in splice are not yet supported');
            });
            return;
        }

        // this should only run if there are deeper level updates in an object within the array from the database
        if (diff.path.indexOf('.') === -1 || diff.path.indexOf('.splices') > -1) return;
        const id = (diff.path.split('.')[1]);
        const dbObj = diff.base[id];
        // will automatically trigger the mongo observer which will then update the data in the store
        DatabaseHolder.getDatabase(collName).update({ _id: dbObj._id }, { $set: dbObj });
    }

    // convenience methods

    _div(a, b) { // eslint-disable-line class-methods-use-this
        return +a / +b;
    }

    _mul(...args) { // eslint-disable-line class-methods-use-this
        return args.reduce((prod, curr) => prod * +curr, 1);
    }

    _sum(...args) { // eslint-disable-line class-methods-use-this
        return args.reduce((sum, curr) => sum + +curr, 0);
    }

    _sub(...args) { // eslint-disable-line class-methods-use-this
        return args.slice(1).reduce((diff, curr) => diff - +curr, args[0]);
    }

    _(val, digits = 2, unit) { // eslint-disable-line class-methods-use-this
        if (!unit) unit = '';
        if (!digits) digits = 0;

        const number = `${(+val).toFixed(digits)}`.replace('.', ',');
        const numArr = number.split(',');
        return `${numArr[0].replace(/\B(?=(\d{3})+(?!\d))/g, '.')},${numArr[1]} ${unit}`;
    }

    _date(date) { // eslint-disable-line class-methods-use-this
        const monthNames = ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'];
        const d = new Date(date);
        return `${d.getDay()}. ${monthNames[d.getMonth()]} ${d.getFullYear()}`;
    }

    _print(...x) { // eslint-disable-line class-methods-use-this
        console.log(x);
    }
};
</script>
